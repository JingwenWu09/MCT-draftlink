# 9, CPAchecker, solver-dependent plugins related bug
```
Me:

typedef char (*F)(unsigned long, void *);
typedef union {
  struct A {
    char a1, a2, a3, a4;
    unsigned long a5;
    F a6;
    void *a7;
  } b;
  char c[1];
} B;
struct C {
  const char *c1;
  unsigned long c2;
};
typedef struct D {
  unsigned long d1;
  int d2;
  const char *d3;
  unsigned long d4, d5;
  struct C d6[49];
  char d7[8];
} E[1];

char baz(unsigned long i, void *j) {
  if (j != 0) {
    __builtin_abort();
  }
  return (char)i;
}

int main() {
  struct D p;
  struct A f;
  __builtin_memset(&f, 0, sizeof(f));
  f.a2 = 4;
  f.a5 = 13;
  f.a6 = baz;
  __builtin_memset(&p, 0, sizeof(p));
  p.d6[0].c1 = (const char *)&f;

  unsigned long k = p.d1 + 1;
  struct C *l = &p.d6[p.d2];
  const char *m = l->c1;
  p.d1 = k;
  if (*m == '\0') {
    struct A *f = &((B *)m)->b;
    unsigned long n = l->c2;
    unsigned long o = n + f->a5;
    if (k < o) {
      unsigned long i;
      unsigned long q = k + 8;
      F a6 = f->a6;
      void *a7 = f->a7;
      if (q > o) {
        q = o;
      }
      
      unsigned long i_1 = i;
      unsigned long k_1 = k;
      unsigned long q_1 = q;
      struct D p_1 = p;
      F a6_1 = a6;
      unsigned long n_1 = n;
      struct C * l_1 =  &p_1.d6[p_1.d2];
      const char * m_1 =  l_1->c1;
      struct A * f_1 =  &((B *)m_1)->b;
      void * a7_1 =  f_1->a7;

      assert(p.d1 == p_1.d1) ;
      assert(p.d2 == p_1.d2) ;
      assert(p.d4 == p_1.d4) ;
      assert(p.d5 == p_1.d5) ;
      char *p_d7_p = &p.d7[0];
      char *p_1_d7_p = &p_1.d7[0];
      for( int i = 0; i < sizeof(p.d7)/sizeof(p.d7[0]); i++ ) {
      	assert(p_d7_p[i] == p_1_d7_p[i]) ;
      }
      assert(q == q_1) ;
      assert(n == n_1) ;
      assert(a6 == a6_1) ;
      assert(k == k_1) ;
      assert(i == i_1) ;
      
      p.d4 = k;
      p.d3 = p.d7;
      p.d5 = q;
    }
  }

  return 0;
}

In this example, the assert() functions are both true, which is confirmed by compiling with gcc and clang,
while CPAchecker gives the Unknown result that shows following information:
Error: Refinement failed: Interpolation failed in solver MATHSAT5 with message
'splitting of AB-mixed terms not supported'. (RefinementFailedException.forInterpolationFailureInSolver, SEVERE)


Command line:
scripts/cpa.sh -predicateAnalysis -64 -preprocess -setprop cpa.predicate.ignoreIrrelevantVariables=false <file_name.c>

```
```
Developer:

The configuration -predicateAnalysis relies on Craig interpolation performed by the solver.
Our default solver is MathSAT5, but unfortunately its interpolation procedure is incomplete and it sometimes gives up.
These are such cases.
The MathSAT5 developers have been made aware of this, but currently cannot solve it.
Unfortunately, we currently also do not have another SMT solver that supports interpolation for QF_AUFBVFP formulas.
So there is nothing we can do right now.

```

