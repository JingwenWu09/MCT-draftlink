# 5, SeaHorn, fixed bmc execution bound related bug
```
Me:

int g = 0;
void foo(int i) {
  g += i; assert (g <= 2);}
void f1() {
  do { foo(1);
    if(g == 1||g == 2) continue;
    break;
  }
  while (1);
}
void f2() {
  do {
    foo(1);
    switch(g) {
      case 1:
      case 2: goto L;
      default: break;
    }
    break;
    L:;
  }
  while (1);
}
void main(void) { 
  f1(); 
  g = 0;
  f2();
}

Theoretically seahorn should both give sat, while the result of example is unsat with command sea bpf -m64 example.c.

OS: Ubuntu 22.04
version: 14.0.0-rc0

```
```
Developer:

This is the standard problem with bounded model checking (BMC).
You need to tell the number of loop unrolls and if you provide a too small number then BMC is incomplete.
If the number is too small then you won't unroll enough loops
so BMC can claim a program is safe but if you would unroll enough
then you would find an execution that violates the property.

By default, the BMC engine unrolls loops only one iteration.
If you add the option --bound=2 SeaHorn will return the expected result sat.

There is an option --assert-on-backedge that adds the so-called unwinding assertions
to make sure that loops are unrolled enough. This option typically works well
but in this case --bound=1 --assert-on-backedge still returns unsat.
I think there is some issue related to the fact that the loop condition is true.
```
```
Developer:

Also the --inline options inlines the function calls early in the pipeline and helps solve this instance faster.
```




