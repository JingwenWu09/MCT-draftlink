# 1, CBMC, confirmed undefined behaviour related bug
```
Me:
#include <stdlib.h>
#include <assert.h>

struct twelve {
    int a;
    int b;
    int c;
    int d;
    int e;
    int f;
};

void testStruct() {
    struct twelve a, b;
    struct twelve *pa = &a;
    struct twelve *pb = &b;
    assert(labs((pa-pb) == 0));
}

void testInt() {
    int i, a[10];
    char *pa = (char *)&a;
    char *pb = (char *)&i;
    assert(labs((pa-pb) == 0));
    int j;
    assert(abs(i) >= 0);
}

int main() {
    testInt();
    testStruct();
    return 0;
}
The assert() functions are true, which is confirmed by compiling with gcc and clang, while cbmc gives the FAILURE result towards assert(labs(pa-pb) == 0), assert(labs(pa-pb) == 0) and assert(abs(i) >= 0) which means the assertions are false. abs(i) is always true, why do assertions fail?

CBMC version: 5.88.0
Operating system: Ubuntu 22.04, macOS
Command line: cbmc example.c
```
```
Developer:
Unless I'm mistaken, your assertions shouldn't be holding - you're invoking undefined behaviour.

According to the C standard n1570-6.5.9:

When two pointers are subtracted, both shall point to elements of the same array object,
or one past the last element of the array object; the result is the difference of the
subscripts of the two array elements. The size of the result is implementation-defined,
and its type (a signed integer type) is ptrdiff_t defined in the <stddef.h> header.
If the result is not representable in an object of that type, the behavior is undefined. In
other words, if the expressions P and Q point to, respectively, the i-th and j-th elements of
an array object, the expression (P)-(Q) has the value iâˆ’j provided the value fits in an
object of type ptrdiff_t. Moreover, if the expression P points either to an element of
an array object or one past the last element of an array object, and the expression Q points
to the last element of the same array object, the expression ((Q)+1)-(P) has the same
value as ((Q)-(P))+1 and as -((P)-((Q)+1)), and has the value zero if the
expression P points one past the last element of the array object, even though the
expression (Q)+1 does not point to an element of the array object.

You're also invoking labs(long i) with a ptrdiff_t argument, which may or may not be automatically promoted to long depending on the platform definitions in stddef.h.
```
```
Developer:
abs(i) >= 0 is not always true. The absolute value of the most-negative value is out of range. That is, abs(-2147483648) is 2147483648 which is out of the range of int.
```
```
Developer:
Since abs(INT_MIN) is undefined behaviour, we should add an assertion to the library model.
```



