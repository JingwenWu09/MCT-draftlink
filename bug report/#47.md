# 20, CPAchecker, confirmed memory allocation related bug
```
Me:

Example 1:
int arr[2];
void fun(int p){
	arr[p] = 2;		//smg false
}
int main(){
	int n = 2;
	fun( n >> 2 & 1  );
	return 0;	
}

Example 2:
int arr[2];
void fun(int p){
	arr[p] = 1;
}
int main(){
	int n = 2;
	int p = n >> 2 & 1;
	fun( p );
	return 0;	
}

Example 3:
int arr[2];
int main(){
	int n = 2;
	int p = n >> 2 & 1;
	arr[p] = 1;
	return 0;	
}

Example 4:
int arr[2];
void fun(int p){
	assert(p == 0);
	arr[p] = 2;
}
int main(){
	int n = 2;
	fun( n >> 2 & 1  );
	return 0;	
}

In Example 1, the SMGAnalysis gives False verification result with the following message,
showing that the statement arr[p] = 1; has invalid pointer dereference :
Verification result: FALSE. Property violation (valid-deref: invalid pointer dereference in line4) found by chosen configuration.

However, after I equivalently transformed Example 1 into Example 2 and Example 3, the SMGAnalysis gave both True results.

In addition, I added the assertion statement assert( p == 0 ); in Example 1 as shown in Example 4.
Then the PredicateAnalysis, ValueAnalysis and KInduction all gave TRUE results that means the assertion was true,
while the SMGAnalysis result became UNKNOWN with the following message, which showed that the assertion was failed:
Error: Unknown function '__assert_fail' may be unsafe. See the cpa.smg.handleUnknownFunctions or cpa.smg.safeUnknownFunctionsPatterns
(SMGBuiltins.handleUnknownFunction, SEVERE)

command line:
./scripts/cpa.sh -valueAnalysis -preprocess -64 -setprop cpa.predicate.ignoreIrrelevantVariables=false -setprop
cpa.predicate.handleStringLiteralInitializers=true <filename.c>

./scripts/cpa.sh -smg -spec ./config/properties/valid-memsafety.prp -preprocess -64 -setprop
cpa.predicate.ignoreIrrelevantVariables=false -setprop cpa.predicate.handleStringLiteralInitializers=true <filename.c>


```
```
Developer:

Unfortunately the SMGAnalysis has some problems and will be replaced by a new SMG analysis soon.
You can try the new analysis with -smg2. But please keep in mind that the
new analysis is currently a explicit value analysis only (while the old SMG analysis is symbolic execution),
meaning that they do different things.
For best results i would recommend using both on a task with the order of SMG2 first, then SMG.
I tested your initial problem with SMG2 by the way, and we return TRUE for that.

```
