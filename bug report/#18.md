# 6, SeaHorn, confirmed combined complex structures related bug
```
Me:
#include  "seahorn/seahorn.h"

union T {
  long l;
  struct {
    char b3, b2, b1, b0;
  } c;
};

int f(union T u) {
  ++u.c.b0;
  ++u.c.b3;
  return (u.c.b1 != 2 || u.c.b2 != 2);
}

int main() {
  union T u;
  u.c.b1 = 2;
  u.c.b2 = 2;
  u.c.b0 = ~0;
  u.c.b3 = ~0;

  union T u_1 = u;

  if( 0 ) {
    abort();
  } else if( (f(u)) ) {
    abort();
  }
  
  if( 0 || (f(u_1)) ) {
    abort();
  }

  sassert(u.l == u_1.l) ;

	return 0;
}
I used clang -m64 example.c and clang -m32 example.c to compile example.c, then ran their executables.
Both results showed that the condition u.l == u_1.l in assert() statement is true.
However, I respectively ran sea bpf -m64 example.c and sea bpf -m32 example.c ,
-m64 gave sat result and -m32 gave unsat result.

In example.c, the variable u has been assigned before it is used.
I don't understand why SeaHorn gave different results than compiler Clang.
Please help me to explain this situation. Thanks.

Version: seahorn 14.0.0
OS: ubuntu 22.04
```
```
Developer:
I think it has to do again with undefined behavior (UB).
With -m32, the size of a long is 4 bytes so there is no UB.
However, with -m64 the size of a long is 8 bytes.
So with -m64 when you compare u.l == u_1.l 4 bytes will be uninitialized.


```



