# 12, SeaHorn, confirmed undefined behaviour related bug
```
Me:
Example 1:

#include "seahorn/seahorn.h"
int main(){
	
	int x = 2;
	int y = 2;

	for(int i=0; i<1; i++){
		x--;
	}
	for(int i=0; i<1; i++){
		y--;
	}

	x = x << 32;
	y = y << 32;

	sassert(x == 0);
	sassert(y == 0); 
	sassert(x == y);	

	return 0;
}

Example 2:

#include "seahorn/seahorn.h"
int main(){

	int si = 0;
	for(int i=0; i<2147483647; i++){
		si++;
	}
	short sx = si;
        sassert(sx == -1);
	sassert(sx != -1);

	return 0;
}

In these two examples, seahorn gives sat result in the Example 1 and unsat result in the Example 2.
Does seahorn have any special treatment for data truncation?
Does seahorn give the sat result if there is some security issue with the program (e.g., if the length of the shift left is greater than the number of bytes of the data type)?
That is, sat is not only for __VERIFIER_error.
Whether some property checks can be ignored by modifying command line directives?
```
```
Developer:
I think in both cases LLVM simplifies the code too aggressively because it detects undefined behavior (UB).
Try to run clang followed by opt with -O3 to see what LLVM produces.
Definitely in the first example it can know that x and y are 1 after the loops because it can unroll those.
Then, it knows that if x and y are integers of 32 bits then the shift 1 << 32 will overflow
and because signed integer overflow is UB then it will remove basically all the code.
```
```
Me:
Can I take it that seahorn gives sat results for UB that exists after clang processing?
```
```
Developer:
It is a little more nuanced than that. By default, SeaHorn runs after clang optimizations.
Clang optimizations preserve behavior only if the code has no UB. There are no guarantees for code that has UB.

SeaHorn will return sat if the input given to it (i.e., after clang and optimization) has an execution that reaches __VERIFIER_error.
If the original input file has UB, the input to SeaHorn might or might not contain an execution that reaches __VERIFIER_error, independently of whether original file had such execution.

In summary, SeaHorn assumes that the input is a well-defined C program that has well-defined semantics
and can be compiled to LLVM bitcode. SeaHorn analyses the bitcode, not the input C programs.
While it is possible to use SeaHorn to detect UB (for example, we use it to detect buffer overflow),
it is not easy and has to be carefully designed to be sound.
```



