# 3, CBMC, confirmed undefined behaviour related bug
```
Me:
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
enum e1 { c1 = -__INT_MAX__};

__attribute__((noinline, noclone)) int f(enum e1 *p, signed int *q) {
  *p = c1;
  *q = 2;
  return *p;
}

enum e2 { c2 = __SHRT_MAX__ + 1};

__attribute__((noinline, noclone)) int g(enum e2 *p, unsigned short *q) {//
  *p = c2;//
  *q = 2;
  return *p;
}

enum e3 { c3 = __SCHAR_MAX__ };

__attribute__((noinline, noclone)) int h(enum e3 *p, unsigned char *q) {
  *p = c3;
  *q = 2;
  return *p;
}

int main() {
  signed x;
  unsigned short y;
  unsigned char z;

  if (f(&x, &x) != 2) {
    abort();
  }
  if (g(&y, &y) != 2) {
    abort();
  }
  if (h(&z, &z) != 2) {
    abort();
  }
  return 0;
}
The assert() functions are true, which is confirmed by compiling with gcc and clang, while cbmc gives the FAILURE result towards
assert(labs(pa-pb) == 0), assert(labs(pa-pb) == 0) and assert(abs(i) >= 0) which means the assertions are false. abs(i) is always
true, why do assertions fail?

CBMC version: 5.88.0
Operating system: Ubuntu 22.04, macOS
Command line: cbmc example.c --pointer-check

What happened:

line 15 dereference failure: pointer outside object bounds in *p: FAILURE
line 17 dereference failure: pointer outside object bounds in *p: FAILURE
line 23 dereference failure: pointer outside object bounds in *p: FAILURE
line 25 dereference failure: pointer outside object bounds in *p: FAILURE

For *p, why do function g and function h have the above failure, but function f does notï¼ŸPlease help me to explain, thanks.
```
```
Developer:
According to the C standard section 6.7.2.2.2 - "The expression that defines the value of an enumeration constant shall be an integer
constant expression that has a value representable as an int." When analysing C code, cbmc currently models the type underlying an enum
as being a signed int. If you form a pointer to a short or a char then those pointers may point to a region of memory which is
smaller than the memory allocated to an enum value. Therefore if you cast these pointers to a pointer to enum type and dereference
them, then you are writing to or reading from memory beyond the memory allocated to the expected destination of the pointer. This
problem is then reported as a dereference failure in the output of cbmc.
```



