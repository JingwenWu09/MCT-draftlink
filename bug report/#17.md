# 6, SeaHorn, confirmed undefined behaviour related work
```
Me:
unsigned int a[2] = {2, 0}, b[2];
void f(unsigned int *sp, int d){
  int i = 0; 
  double n = 1.01;
  unsigned int *p, *top; 
  top = sp; 
  sp -= 1;
  for (p = sp; p <= top; p++)
    if (*p < 2) {
      if (d) (*p) = (i * 8) - n;
      else (*p) = (i << 3) - n; 
    }
}
void main() {
  memcpy (b, a, sizeof(b));
  f(a + 1, 0);
  f(b + 1, 1);
  assert (a[1] == b[1]); 
}

In this case, I run sea bpf -m64 example.c and SeaHorn gave the sat result.
So I ran the following commands sea bpf --cex=witness.ll example.c,
sea exe -m64 -g example.c witness.ll -o example.exe ,
./example.exe in turn to see the executable counterexample.
But the .exe dit not have any output on the terminal, that is,
I did not see the information "[sea] __VERIFIER_error was executed".

Then I arbitrarily changed the value of n (e.g. 2.0, 343.00, 4.123, etc.)
and found that when the fractional part of n is 0,
the result of the command is unsat, otherwise, the result is sat.

I have the following questions:

For the sat result of example.c, why does the executable counterexample not give
the message "[sea] __VERIFIER_error was executed"?
Is it because SeaHorn checks for something other than assert(); statement in the code?

For this example involving type conversion, why does SeaHorn validate differently on
whether the fractional part of a floating-point number is zero?

Please help me to explain this situation. Thanks.

Version: seahorn 14.0.0
OS: ubuntu 22.04
```
```
Developer:
Seahorn does not support floating points. My guess is that when n=1.0 LLVM cast it to an integer.
```



