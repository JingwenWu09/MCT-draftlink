# 7, CBMC, unconfirmed bmc execution bound related bug
Me:

```
Example 1:
struct {
  char a3c;
  char a3p[];
} a3 = {'o', "wx"};

int main() {
  if (a3.a3p[0] != 'w') {
    abort();
  }
  if (a3.a3p[1] != 'x') {
    abort();
  }
  return 0;
}
```
```
Example 2:
#include<assert.h>
int a[][2][4] = {[2 ... 4][0 ... 1][2 ... 3] = 1, [2] = 2, [2][0][2] = 3};
int main(void) {
	assert( sizeof(a)/(sizeof(int)*2*4) == 5);
}
```

In the Example 1, run  cbmc example1.c --bounds-check generate following output results:
[main.array_bounds.1] line 10 array 'a3'.a3p upper bound in a3.a3p[(signed long int)0]: FAILURE
[main.array_bounds.2] line 13 array 'a3'.a3p upper bound in a3.a3p[(signed long int)1]: FAILURE

In the Example 2, the assert() function is true, which is confirmed by compiling with gcc and clang,
while cbmc gives the FAILURE result by running cbmc example2.c.

Is it related that the size of the first dimension is omitted when the array is defined?

CBMC version: 5.88.0
Operating system: Ubuntu 22.04, macOS
Command line: cbmc example.c



